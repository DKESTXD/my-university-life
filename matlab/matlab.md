# 一，绪论

## 1.1 数学模型

用数学语言来表达物理系统或过程本质特征的公式或方程。

因变量=f(自变量，参数，强制因素)

1. 因变量：用来刻画系统行为与状态的特征量。
2. 自变量：通常为维度，如时间空间，系统的行为由自变量确定
3. 参数：反映系统的性质或组成
4. 强制函数：外部对系统施加的影响

数值计算方法是通过计算机求工程问题满足精度要求的近似解的学科。

## 1.2 误差

### 1.2.1 定义

舍入误差：由于计算机只能表示有限位数的量引起的

截断误差：由于数值方法可能运用近似方法表示准确数值运算或数量引起的

有效数字

准确度：计算机或测量值与真值的接近程度

精度/精确度：各计算量或测量值相互之间的集中程度

误差：源于用近似方法表示准确的数学运算和准确的数量

- 用近似方法表示准确数学过程会出现截断误差
- 当用有限个有效数字表示准确的数时会出现舍入误差

绝对误差：真值-近似值   $$E=x-x^*$$  可正可负，一般准确值很难给出，用真值的最优估计值代替，或者给出误差的上界$$\delta(x^*)$$，定义为误差限

相对误差：$$\varepsilon_r=\frac{E}{x}\times100\%$$  当x为0时相对误差无意义，准确值往往未知，常用$$x^*$$代替$$x$$

相对误差限：$$\frac{\delta(x^*)}{|x^*|}$$

<img src="D:\新建文件夹 (5)\img1\微信截图_20250221142041.png" alt="微信截图_20250221142041" style="zoom: 50%;" />

### 1.2.2 有效数字与误差

取有效数字时采取四舍五入，这样其误差不超过近似数末位数的半个单位，即$$|\pi-3.1416|\leq\frac{1}{2}\times10^{-4}$$

同理由此定义 $$x^*$$是$$x$$近似n位有效数字

<img src="https://pb.nichi.co/wrong-swear-muscle" style="zoom: 50%;" />

迭代方法的误差估计：

​	当前迭代结果的误差：$$\varepsilon_a=\frac{当前近似值-上一个近似值}{当前近似值}\times100\%$$

​	通常不关注符号，采用绝对值与预设好的容限$$\varepsilon_s$$对比 ，$$|\varepsilon_a|<\varepsilon_s$$

​	如果$$\varepsilon_s=(0.5\times10^{2-n})\%$$，一般至少可以保证至少有n位有效数字是正确的

### 1.2.3 数的计算机表示

浮点表示：$$r=m\times b^e$$

- m为尾数，存储了有限的有效数字，会引入舍入误差

- b为基数：是几进制的意思

- e为指数

  <img src="D:\新建文件夹 (5)\img1\微信截图_20250221145312.png" alt="微信截图_20250221145312" style="zoom: 50%;" />

仅能接受有限范围的数，超出会溢出，不能接受非常小的数，在0与第一个正数之间有一个洞

在可接受范围内只能表示有限个数的数，无理数以及不与该集合中的数对应的有理数均不能准确表示，即量化误差；有效数字足够多时，总的舍入误差可以忽略不计。

数之间的间隔随着数大小增大而增大，量化误差与数的大小成比例。相对量化误差：舍去的情况$$\frac{|\Delta x|}{x}\leq \varepsilon$$  舍入的情况$$\frac{|\Delta x|}{x}\leq \frac{\varepsilon}{2}$$ 

其中$$\varepsilon=b^{1-t}$$  为机器精度，t为尾数的有效数字个数

在迭代过程中，当对一个量的收敛性或迭代过程是否中止，测试它们的差是否小于某个可接受的容限。可用机器精度作为停止或收敛准则。

### 1.2.4 计算机中的数学运算

加减乘除：有效数字丢失

- 加减法：较小数的尾数调整，使两个数指数相等

- 乘法：指数相加，尾数相乘，两个n位尾数得到2n位尾数

- 除法：指数相除，尾数相减，然后再进行归一化和舍入处理。

  <img src="D:\新建文件夹 (5)\img1\微信截图_20250221150352.png" alt="微信截图_20250221150352" style="zoom:50%;" />

大规模计算：舍入误差累积

大数加小数：调整较小数，使其指数与大数匹配，再舍去处理

减性抵消：两个几乎相等的浮点数相减时引起的舍入误差

拖尾效应：求和时如果某一项的值大于和值本身，就会发生拖尾效应。

### 1.2.5 截断误差与泰勒级数

截断误差：运用近似方法表示准确数值运算或数量而引起的误差

<img src="D:\新建文件夹 (5)\img1\微信截图_20250226141936.png" alt="微信截图_20250226141936" style="zoom:50%;" />

- 零阶近似：$$f(x_{i+1})=f(x_i)$$

- 一阶近似：$$f(x_{i+1})=f(x_i)+f^{'}(x_i)(x_{i+1}-x_i)$$

- 完整的泰勒展开：

  <img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250226142648950.png" alt="image-20250226142648950" style="zoom:50%;" />

通常，n阶多项式的n阶泰勒级数展开得到的结果是准确的。对于其他连续可微函数，如指数函数和正弦函数，有限级数项是不可能得到准确结果的。每增加一项将使近似结果得到一定的改进，但改进程度不显著。

只需少数项便可获得一个足够精确的估计值。

余项$$R_n=\frac{f^{n+1}(\xi)}{(n+1)!}h^{n+1}$$    $$R_n=O(h^{n+1})$$，即误差与步长的n+1次方成正比。

如果h足够小，前几阶占估计值的绝大部分，只需前几阶误差便可极小。



非线性与步长对泰勒级数逼近的影响：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250226145154.png" alt="微信截图_20250226145154" style="zoom:50%;" />

### 1.2.6 误差的传播与估计

#### 单变量函数

设函数$$f(x)$$，x* 是x的近似值，估计x* 与x的差异对函数值的影响：$$\Delta f(x^*)=|f(x^*)-f(x)|$$，用泰勒级数逼近，可得

$$\Delta f(x^*)=|f^{'}(x^*)||x-x^*|$$

#### 多变量函数

$$\Delta f(u^*,v^*)=|\frac{\partial f}{\partial u}|\Delta u^*+|\frac{\partial f}{\partial v}|\Delta v^*$$

$$\Delta f(x_1^*,x_2^*,...,x_n^*)=|\frac{\partial f}{\partial x_1}|\Delta x_1^*+|\frac{\partial f}{\partial x_1}|\Delta x_1^*+...+|\frac{\partial f}{\partial x_n}|\Delta x_n^*$$

#### 一般运算

<img src="D:\新建文件夹 (5)\img1\微信截图_20250226151111.png" alt="微信截图_20250226151111" style="zoom:50%;" />

函数导数的绝对值很大时，数据误差在运算中传播后，可能会导致结果的很大误差。

在无限迭代的序列中误差选用不同的算法误差的累积效果不一样。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250301141443.png" alt="微信截图_20250301141443" style="zoom:50%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250301141510.png" alt="微信截图_20250301141510" style="zoom:50%;" />

### 1.2.7 稳定性与条件性

一个算法如果原始数据有误差，而计算过程舍入误差不增长，则称此算法是数值稳定的，否则，若误差增长，则称算法是不稳定的。（输入值的不确定性通过数值方法在总体上是放大的）

条件数定义为相对误差之比：

f(x)相对误差为$$\frac{f(x)-f(x*)}{f(x*)}=\frac{f^{'}(x*)(x-x*)}{f(x*)}$$，x相对误差为$$\frac{x-x*}{x*}$$

条件数为:$$|\frac{x*f^{'}(x*)}{f(x*)}|$$

条件数体现了x的不确定性被x)放大程度。如果条件数等于1，表示函数的相对误差等于x的相对误差，如果条件数大于1，表示相对误差被放大了，而条件数小于1，表示相对误差减小了。

条件数非常大(大于等于10)的函数称为病态函数。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250301142316.png" alt="微信截图_20250301142316" style="zoom:50%;" />

为了最小化舍入误差，计算机会增加有效数字个数，缩短步长使得截断误差减小，但是会使计算量增大，舍入误差变大。大多数计算机可以表示足够多的有效数字，舍入误差不会占据主导地位。

避免误差危害：

- 选择数值稳定的计算方法，避开不稳定的算式。
- 注意简化计算步骤及公式，设法减少运算次数;选用运算次数少的算式尤其是乘方幂次要低，以减少舍入误差，同时可节约计算机的机时。
- 合理安排计算顺序，防止大数“淹没”小数。多个数相加时，最好从绝对值最小的数到绝对值最大的数依次相加;多个数相乘时，最好从有效位数最多的数到有效位数最少的数依次相乘
- 避免两相近数相减。
- 避免用绝对值很小的数作为除数。

# 二，非线性方程求根

设有非线性方程f(x)=0
当f(x)为多项式时，且最高次为n，称f(x)=0为n次代数方程，如果f(x)包含指数函数或三角函数等特殊函数时，称f(x)=0为超越方程
如果f(x)可拆为$$f(x)=(x-x^*)^mg(x)$$，称x*为m重根，一个就是单根

两个问题：

- 预先给出根的一个初略位置（根的分离），然后根据这个位置向真实根逼近（近似根的精确化）
- 求解多项式的所有实数根和复数根。专为多项式设计，系统化地求解多项式的所有根，而不仅仅是逼近的实数根

有根区间的情况：

- 两端点同号，中间无根
- 两端点同号，中间偶数根
- 两端点异号，中间奇数根
- 特殊情况：与x轴相切，不连续函数。

### 2.1 二分法

#### 2.1.1 步骤

首先确定有根区间，将区间二等分，通过判断f(x)的符号，逐步将有根区间缩小，直至有根区间足够地小，便可求出满足精度要求的近似根。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250301151327.png" alt="微信截图_20250301151327" style="zoom:67%;" />

#### 2.1.2  误差估计

<img src="D:\新建文件夹 (5)\img1\微信截图_20250301151552.png" alt="微信截图_20250301151552" style="zoom:67%;" />

近似误差总会大于真实误差，可认为近似误差是真实误差的一个精确上界，近似误差满足要求真实的一定也满足。

#### 2.1.3 迭代次数

设初始区间长度$$L_0$$，最终期望绝对误差$$E_{a,d}$$

迭代次数为：$$n=\frac{log(L_0/E_{a,d})}{log2}$$

#### 2.1.4 代码实现

```matlab
function [c,err,yc]=bisect(f,a,b,delta)
%input-f是函数，a、b是左右边界值，delta是容限
%output-c是零点，yc是f(c)，err是误差
ya=feval(f,a);
yb=feval(f,b);
if(ya*yb>0)
	break
end
max1=1+round((log(b-a)-log(delta))/log(2));
for k=1:max1
	c=(a+b)/2;
	yc=feval(f,c);
	if yc==0
		a=c;
		b=c;
	elseif yb*yc>0
		b=c;
		yb=yc;
	else
		a=c;
		ya=yc;
	end
	if b-a<delta
		break;
	end
end
c=(a+b)/2;
err=abs(b-a)/2;
yc=feval(f,c);
```

#### 2.1.5 评价

优点

- 简单，能找出根
- 迭代次数能算

缺点

- 慢，要求上下界已知，对与x轴相切的处理不了
- 多根无法处理
- 对异号无根的处理不了。

### 2.2 试位法

#### 2.2. 1 步骤

<img src="D:\新建文件夹 (5)\img1\微信截图_20250301153442.png" alt="微信截图_20250301153442" style="zoom:67%;" />

```matlab
function [c,err,yc]=regular(f,a,b,delta,epsilon,max1)
%input-f是函数，a、b是左右边界点，delta是相邻两次迭代值之间误差的容限，epsilon是当前点的函数值与0之间差的容限，max1是最 %  大迭代次数
%output-c是零点，yc是f(c)，err是误差
ya=feval(f,a);
yb=feval(f,b);
if ya*yb>0
	break;
end
for k=1:max1
	dx=yb*(b-a)/(yb-ya);
	c=b-dx;
	ac=c-a;
	yc=feval(f,c);
	if yc==0 
		break;
	elseif yb*yc>0
		b=c;
		yb=yc;
	else
		a=c;
		ya=yc;
	end
	dx=min(abs(dx),ac);
	if abs(dx)<delta
		break;
	end
	if abs(yc)<epsilon
		break;
	end
end
c;
err=abs(b-a);
yc=feval(f,c);
```

试位法比二分法误差减小的快。

#### 2.2. 2 缺陷

试位法收敛慢
近似误差小于真实误差：除了检查迭代近似误差外，把根的估计值代入原方程中，检验是否接近0
一个划界点保持不动可能导致很差的收敛性。

#### 2.2. 3 修正

检测一个边界值是否固定不变，用一个计数器，如果某个边界值两次迭代不变，将此边界点的函数值变为原来的一半。

#### 2.2. 4 增量搜索和确定初始猜值

<img src="D:\新建文件夹 (5)\img1\微信截图_20250301154547.png" alt="微信截图_20250301154547" style="zoom:67%;" />

### 2.3 不动点迭代法

#### 2.3.1 定义

重组方程：把$$f(x)=0$$转化为$$x=g(x)$$,然后$$x_k=g(x_{k-1})$$进行迭代，其中x0已知。

相对误差：$$\varepsilon_a=|\frac{x_{i+1}-x_i}{x_{i+1}}|\times 100\%$$

不动点：函数g(x)的一个不动点指一个实数P满足$$P=g(P)$$，从图形上看是$$y=g(x),y=x$$的交点

定理：设g(x)是一个连续函数，且$$\{P\}^\infty_{n=0}$$是不动点迭代生成的序列，如果当n->无穷时序列收敛于P，那么P就是g(x)的一个不动点。
	    <img src="D:\新建文件夹 (5)\img1\微信截图_20250305131730.png" alt="微信截图_20250305131730" style="zoom:50%;" />

转化为迭代函数时，可能会不收敛，就算收敛，收敛情况也不一样，注意选择。

四种迭代情况：均可在图中看出迭代的过程。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305132346.png" alt="微信截图_20250305132346" style="zoom:67%;" />

迭代函数的选择：不动点定理

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305133431.png" alt="微信截图_20250305133431" style="zoom:50%;" />

#### 2.3.2 程序实现

```matlab
function [k,p,err,P]=fixpt(g,p0,tol,max1)
%input-g是迭代函数，p0是不动点初始值，tol是容限，max1是最大迭代次数
%output-k是当前迭代的次数，err是误差，p是不动点最终结果，P是p迭代的序列
P(1)=p0;
for k=2:max1
	P(k)=feval(g,P(k-1));
	err=abs(P(k)-P(k-1));
	relerr=err/abs(P(k)+eps);
	p=P(k);
	if (err<tol)||(relerr<tol),break;end
end
if k==max1
	disp("最大迭代次数已经达到")
end
end
```

由导数中值定理可以论证不动点迭代法的合理性。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305142910.png" alt="微信截图_20250305142910" style="zoom: 50%;" />

### 2.4 Newton-Raphson法

#### 2.4.1 定义

已知$$f(x_{i+1})\approx f(x_i)+f^{'}(x_i)(x_{i+1}+x_i)$$
假设$$x_{i+1}$$就是f(x)的零点，函数值为0，那么则有$$0\approx f(x_i)+f^{'}(x_i)(x_{i+1}+x_i)$$
即$$x_{i+1}=x_i-\frac{f(x_i)}{f^{'}(x_i)}$$，就是寻找$$g(x)=x-\frac{f(x)}{f^{'}(x)}$$的不动点

N-R方法比不动点迭代法收敛的快得多，每次迭代误差减小比不动点方法快得多。

#### 2.4.2 误差分析

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305145105.png" alt="微信截图_20250305145105" style="zoom:67%;" />

#### 2.4.3 收敛阶

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305150607.png" alt="微信截图_20250305150607" style="zoom:67%;" />

#### 2.4.4 收敛速度

设N-R迭代产生的序列{xn}收敛到函数的根xr，如果xr是单根，则{xn}是二次收敛，而且对于足够大的n来说有

$$|E_{n+1}|\approx \frac{|f^{''}(x_r)|}{2|f^{'}(x_r)|}|E_n|^2$$，即$$A=\frac{|f^{''}(x_r)|}{2|f^{'}(x_r)|}$$

如果xr是M阶多重根，则{xn}是线性(一阶)收敛，而且对于足够大的n有$$|E_{n+1}|\approx \frac{M-1}{M}|E_n|$$

#### 2.4.5 缺点

- 在根附近出现拐点，$$f^{''}(x)=0$$， 迭代逐渐远离根；

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305152735.png" alt="微信截图_20250305152735" style="zoom: 67%;" />

- 在局部极值点附近振荡

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305152742.png" alt="微信截图_20250305152742" style="zoom:67%;" />

- 跳过了几个根

  <img src="D:\新建文件夹 (5)\img1\微信截图_20250305152750.png" alt="微信截图_20250305152750" style="zoom:67%;" />

- $$f^{'}(x)=0$$，被零除，解沿水平方 向永远不会和x轴相交；

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305152755.png" alt="微信截图_20250305152755" style="zoom:67%;" />

收敛性依赖于函数的性质和初始猜测的准确度

#### 2.4.6 代码实现

- 将最终的估计根代入原始函数中检查f(x)是否为0，防止由于收敛很慢或振荡 收敛导致很小的$$ε_a$$但根却离真实根仍然很远。
- 确定迭代上限，避免因振荡、慢收敛或发散的情况导致无限循环。
- 判断$$f^{'}(x)=0$$的概率并通知用户

```matlab
function [p0,err,k,y]=newton(f,df,p0,delta,epsilon,max1)
%input-f是函数，df是函数一阶导，p0是初始值，delta迭代两次差的容限，epsilon是迭代当前结果函数值与0之间差的容限，max1最大
%迭代次数
%output-p0是最后结果结果，k是当前迭代次数，y是f(p0)函数值
for k=1:max1
	p1=p0-feval(f,p0)/feval(df,p0);
	err=abs(p1-p0);
	relerr=2*err/(abs(p1)+delta);
	p0=p1;
	y=feval(f,p0);
	if(err<delta)||(relerr<delta)||(abs(y)<epsilon),break;end
end
end
```

### 2.5 割线法（正割法，Secant Method）

#### 2.5.1 定义

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305213527.png" alt="微信截图_20250305213527" style="zoom:67%;" />

类似于N-R方法，用差商表示斜率。
类似于试位法：用两个估计值来计算函数斜率的近似，并投射到x轴上获得一个新的估计值。
收敛阶：1.618

#### 2.5.2 程序实现

```matlab
function [p1,err,k,y]=secant(f,p0,p1,delta,epsilon,max1)
%input-f是函数，p0是初始值，p1也是估计值，delta是相邻两项的容限，epsilon是y的容限，max1是最大迭代次数
%output-p1是估计值，err是误差，y是函数值
for k=1:max1
	p2=p1-feval(f,p1)*(p1-p0)/(feval(f,p1)-feval(f,p0));
	err=abs(p2-p1);
	relerr=2*err/(abs(p2)+delta);
	p0=p1;
	p1=p2;
	y=feval(p1);
	if (err<delta)||(relerr<delta)||(abs(y)<epsilon),break;end
end
end
```

#### 2.5.3 与试位法区别

试位法一般收敛，割线法可能发散，如果割线法收敛，比试位法快。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305221322.png" alt="微信截图_20250305221322" style="zoom:50%;" />

#### 2.5.4 改进

估计导数：通过独立变量的小量扰动来估计

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305224233.png" alt="微信截图_20250305224233" style="zoom:67%;" />

$$\delta$$是一个待定变量，需要人为确定，算法不会自己选择合适的$$\delta$$，如果$$\delta$$太小可能会因为分母的减性抵消引起的舍入误差淹没。
如果选择正确，当导数难以计算或者两个初始值不易获得时，是一种好的算法。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305224740.png" alt="微信截图_20250305224740" style="zoom:67%;" />

#### 2.5.5 重根问题

定义一个新函数$$u(x)=\frac{f(x)}{f^{'}(x)}$$，这个函数与原函数有相同的根
<img src="D:\新建文件夹 (5)\img1\微信截图_20250305225225.png" alt="微信截图_20250305225225" style="zoom:50%;" />

改进的割线法$$x_{i+1}=x_i-u(x_i)\frac{x_i-x_{i-1}}{u(x_i)-u(x_{i-1})}$$，即把f(x)替换为了u(x)。

### 2.6 总结

<img src="D:\新建文件夹 (5)\img1\微信截图_20250305225754.png" alt="微信截图_20250305225754" style="zoom:80%;" />

重点在于迭代公式，误差与终止准则的选择。

### 2.7 matlab自带的相关函数

涉及多项式求根和方程组求根

| 函数     | 描述                       |
| -------- | :------------------------- |
| fzero    | 单函数求根                 |
| roots    | 求多项式的根               |
| poly     | 用已知根构建多项式         |
| polyval  | 求多项式的值               |
| polyvalm | 求带有矩阵变量的多项式的值 |

# 三，线性代数方程组

$$
\begin{equation}
	\left\{
		\begin{array}{lr}
		a_{11}x_1+a_{12}x_2+...+a_{1n}x_n=b_1 \\
		a_{21}x_1+a_{22}x_2+...+a_{2n}x_n=b_2 \\
		...\\
		a_{n1}x_1+a_{n2}x_2+...+a_{nn}x_n=b_n
        \end{array}
	\right.
\end{equation}
$$

矩阵AX=B
$$
A=\begin{bmatrix}
	a_{11}&a_{12}&...&a_{1n}\\
	a_{21}&a_{22}&...&a_{2n}\\
	...&...&...&...\\
	a_{n1}&a_{n2}&...&a_{nn}
\end{bmatrix}
$$
​                                                                       $$X=\begin{bmatrix}x_{1}&x_{2}&...&x_{n}\\\end{bmatrix}^T$$           $$B=\begin{bmatrix}b_{1}&b_{2}&...&b_{n}\\\end{bmatrix}^T$$
$$
增广矩阵=\begin{bmatrix}
	a_{11}&a_{12}&...&a_{1n}&b_1\\
	a_{21}&a_{22}&...&a_{2n}&b_2\\
	...&...&...&...&...\\
	a_{n1}&a_{n2}&...&a_{nn}&b_n
\end{bmatrix}
$$
系数矩阵的类型：

- 低阶稠密矩阵
- 大型稀疏矩阵（零元素较多）
- 三对角矩阵（非0元素集中于主对角线以及相邻两对角线上）

## 3.1 直接法

经过有限步算术运算，可求得方程组的精确解的方法（若在计算过程中没有舍入误差）
可预先估算使用机器时间，计算量小，但要占用较多内存，程序复杂。一般说来，适用于方程组的系数矩阵阶数不太高的问题。

### 3.1.1 非计算机方法

#### 3.1.1.1  图解法

在二维坐标系中画出两条直线，交点即为联立方程组的解

三个方程组成的联立方程组：每个方程是三维空间中的一个平面，三个平面的交点表示方程组的根

<img src="D:\新建文件夹 (5)\img1\微信截图_20250314203754.png" alt="微信截图_20250314203754" style="zoom:67%;" />

#### 3.1.1.2  克莱姆法则

每个未知数通过一个分式来计算
分式的分母是线性代数方程组的行列式
分子是另外一个行列式，该行列式与方程组系数行列式D只有未知数对应的一列不同，不同的列为常数b1， b2，…， bn

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323093057.png" alt="微信截图_20250323093057" st="zoom:67%;" />

未知数消去法，用已知的根求额外根。

### 3.1.2 计算机方法

#### 3.1.2.1  原始高斯消去法

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323093358.png" alt="微信截图_20250323093358" style="zoom: 50%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323093422.png" alt="微信截图_20250323093422" style="zoom:50%;" />



原理非常简单，代码实现如下（只适用于n×n方阵）

```matlab
function x=Gauss(a,b)
    [m,n]=size(a);
    for k=1:n-1
        for i=k+1:n
            factor=a(i,k)/a(k,k);
            for j=k+1:n
                a(i,j)=a(i,j)-factor*a(k,j);
            end
            b(i)=b(i)-factor*b(k);
        end
    end
    x(n)=b(n)/a(n,n);
    for i=n-1:-1:1
        sum=b(i);
       for j=i+1:n
           sum=sum-a(i,j)*x(j);
       end
       x(i)=sum/a(i,i);
    end
```

消去过程的时间复杂度：$$\frac{2n^3}{3}+O(n^2)$$；回代过程的时间复杂度：$$n^2+O(n)$$；
总的时间复杂度：$$\frac{2n^3}{3}+O(n^2)$$；

缺陷：消去与回代会出现被0除的情况
舍入误差过大：每一个计算结果都依赖于前一个结果，误差会累积
奇异方程组：两个方程组完全相等时，n个未知数而只有n-1个方程；对大规模方程组，不容易发现这种奇异性；利用奇异方程组的行列式为0进行判断
病态方程组：系数的微小改变会导致解的剧烈变化。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323101252.png" alt="微信截图_20250323101252" style="zoom:67%;" />

矩阵求逆
稍微改变系数然后求解，如果得到彻底不同的解，则方程组很可能是病态的。

#### 3.1.2.2 解求精技术

##### 3.1.2.2.1 使用拓展精度

##### 3.1.2.2.2 列主元消去法

从第一列中选出绝对值最大的元素，将最大元素对应的行换到第一行，然后进行一次消元。在从第2行到第n行中的第二列找到绝对值最大元素，把对应此行换到第二行；此后都依次这样操作，直到消元完毕；

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323150048.png" alt="微信截图_20250323150048" style="zoom:50%;" />

##### 3.1.2.2.3 全主元消去法

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323145820.png" alt="微信截图_20250323145820" style="zoom: 50%;" />

##### 3.1.2.2.4 缩放

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323150329.png" alt="微信截图_20250323150329" style="zoom:50%;" />

#### 3.1.2.3 高斯-约当法

- 高斯消去法的变形
- 把所有方程的未知数都消去
- 每个方程除以其主元进行标准化
- 最后的结果是一个单位阵
- 只需要消去，不需要回代

步骤：每行依次消，矩阵的对角线标准化为0；先消成上三角矩阵，然后每行消，消成单位矩阵

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323151430.png" alt="微信截图_20250323151430" style="zoom:50%;" />

#### 3.1.2.3 高斯消去法评价

- 条件苛刻，数值不稳定
- 全主元消去法工作量偏大，需要比较的元素及行列交换工作较多，算法复杂
- Gauss-Jordan消去法形式上比其他消元法简单，且无回代求解，但计算量大
- 从算法优化的角度考虑， Gauss列主元消去法比较好

### 3.1.3 LU分解、特殊矩阵

#### 3.1.3.1 三角分解（LU分解）

​								A=LU

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323152908.png" alt="微信截图_20250323152908" style="zoom:50%;" />

Doolittle分解：
定理：当A的各阶顺序主子式均不为零时，Doolittle分解可以实现并且唯一。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323153501.png" alt="微信截图_20250323153501" style="zoom: 50%;" />

计算顺序：

1，先求U第一行与L第一列：U的第一行$$u_{1i}=a_{1i}$$；L的第一列$$l_{11}=1,l_{k1}=a_{k1}/u_{11}$$
2，求出U前k-1行与L前k-1列后，第k步中计算U的第k行与L的第k列
$$
u_{ki}=a_{ki}-\sum^{k-1}_{j=1}l_{kj}u_{ji}\ \ \ \ \ \ i=k,...,n\\
l_{ik}=(a_{ik}-\sum^{k-1}_{j=1}l_{ij}u_{jk})/u_{kk}\ \ \ \ \ \ i=k+1,...,n;k\neq n
$$
向前代入求解LY=B
$$
y_1=b_1\\
y_k=b_k-\sum^{k-1}_{j=1}l_{kj}y_j\ \ \ \ \ \ k=2,...,n
$$
向后代入求解UX=Y
$$
x_n=y_n/u_{nn}\\
x_k=(y_k-\sum^n_{j=k+1}u_{kj}x_j)/u_{kk}\\
k=n-1,...,1
$$
要先前向求解Y再反向求解X

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323155541.png" alt="微信截图_20250323155541" style="zoom:50%;" />

#### 3.1.3.2 与高斯消元法比较

三角分解的时间复杂度：
分解：$$\frac{n^3-n}{3}$$；代入$$n^2$$

随着n增加，LU分解与高斯消元法计算量相当
直接三角分解法是从矩阵A的元素直接由关系式A=LU确定L和U的元素，不必像Gauss消去法那样计算那些中间结果
高斯消去法求解方程组时，右端项必须提前知道，三角分解则不需要
在实现A=LU分解后，解具有相同系数矩阵的方程组AX=Bj相当方便，每解一个方程组只需求解两个三角形方程组，用n2次乘除法运算即可完成求解。

### 3.1.4 求逆

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323155945.png" alt="微信截图_20250323155945" style="zoom:50%;" />

### 3.1.5 对称正定矩阵的平方根法（Cholesky分解）

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323160328.png" alt="微信截图_20250323160328" style="zoom:50%;" />

由Doolittle分解，A由唯一分解A=LU

LDR分解：A分解为A=LDR ，L、R分别为单位下、上三角阵，D为一个对角阵。

对称正定矩阵A有三角分解$$A=LDL^T$$

假设A是n阶实对称正定矩阵，则必存在非奇异下三角矩阵L，使$$A=LL^T$$，并且当L的主对角元均为正时，这种分解是唯一的。称$$A=LL^T$$为矩阵A的Cholesky分解。

#### 3.1.5.1 Cholesky分解过程：
<img src="D:\新建文件夹 (5)\img1\微信截图_20250323160640.png" alt="微信截图_20250323160640" style="zoom:50%;" />

#### 3.1.5.2 优缺点

优点：数值稳定（不需要交换主元），存储量小，计算量小，约需$$\frac{x^3}{6}$$次乘除法，大约是高斯消去法或Doolittle
分解法的一半
缺点：存在开方运算，可能会出现根号下负数

### 3.1.6 改进的Cholesky分解

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323162156.png" alt="微信截图_20250323162156" style="zoom:50%;" />

### 3.1.7  三对角方程组的追赶法   Thomas算法

带状方程组：除了主对角线为中心的一个带状范围内的元素不为零，其他元素都为零；带宽BW，半带宽HBW；如果|i-j|>HBW，aij=0

高斯消去或LU分解求解带状方程组效率低<img src="D:\新建文件夹 (5)\img1\微信截图_20250323162504.png" alt="微信截图_20250323162504" style="zoom:50%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323162728.png" alt="微信截图_20250323162728" style="zoom:50%;" />

每行对角线上的值最大，而且比左右两者的和都大。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323162945.png" alt="微信截图_20250323162945" style="zoom:50%;" />

计算公式
（1）分解计算公式A=LU
$$
\beta_1=c_1/b_1\\
\beta_i=c_i/(b_i-a_i\beta_{i-1})\ \ \ \  i=2,...,n-1
$$
（2）求解Ly=f的递推算式
$$
y_1=f_1/b_1\\
y_i=(f_i-a_iy_{i-1})/(b_i-a_i\beta_{i-1})\ \ \ \ \ i=2,...,n
$$
（3）求解Ux=y的递推算式
$$
x_n=y_n\\
x_i=y_i-\beta_ix_{i+1}\ \ \ \ \ \ \ i=n-1,...,1
$$
对于舍入误差是稳定的，仅需5n−4次乘除法运算。

## 3.2 迭代法

### 3.2.1 误差分析和方程组条件数

利用逆矩阵确定方程组是否病态的方法：

- 缩放系数矩阵A，使其每一行的最大元素为1。计算缩放后的逆矩阵，如果$$A^{-1}$$中有元素的值大于1几倍，则方程组是病态的。
- 将逆矩阵与原矩阵相乘，检查结果是否接近单位阵。如果不接近单位阵，则方程组是病态的。
- 求逆矩阵的逆矩阵，与原系数矩阵对比。如果不相等，则方程组是病态的。

### 3.2.2 向量与矩阵的范数

#### 向量的范数
定义：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323164239.png" alt="微信截图_20250323164239" style="zoom:50%;" />

几种向量范数：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323164342.png" alt="微信截图_20250323164342" style="zoom:50%;" />

#### 矩阵的范数：

​                                                          <img src="D:\新建文件夹 (5)\img1\微信截图_20250323164424.png" alt="微信截图_20250323164424" style="zoom:50%;" />
​                                                            <img src="D:\新建文件夹 (5)\img1\微信截图_20250323164447.png" alt="微信截图_20250323164447" style="zoom:50%;" />

#### 谱和谱半径：

- A∈Rn×n的特征值为λ1，λ2 ，…，λn
- 称A的所有特征值的集合为A的谱
- 称ρ(A)=max|λi|为A的谱半径

||A|| 为A的任意一种范数，有ρ(A)≤||A||

#### 严格对角占优阵：

​                                                               <img src="D:\新建文件夹 (5)\img1\微信截图_20250323164743.png" alt="微信截图_20250323164743" style="zoom:50%;" />

#### 病态方程与矩阵条件数：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323165032.png" alt="微信截图_20250323165032" style="zoom:50%;" />

扰动方程(A+∆A)x=b+∆b

- 如果方程组的系数或常数项有微小改变时，解会发生很大的改变，则称这种方程组为“病态”的
- 扰动方程的解与原方程的解相对误差不大，称为良态方程
- 方程组的“条件”问题
- 一般说来，在用计算机解方程组时，实际上解的都是扰动方程，这是由于计算过程中不可避免地会产生舍入误差
- 对于良态问题，只要数值方法是稳定的，就可以得到较好的结果
- 而对于病态问题，即使算法是稳定的，其计算结果有时也会很坏

误差界：
                                   <img src="D:\新建文件夹 (5)\img1\微信截图_20250323165307.png" alt="微信截图_20250323165307" style="zoom:50%;" />



条件数：设$$A∈R^{n×n}$$，非奇异，$$Cond(A)=||A||\ ||A^{-1}||$$；$$K(A)=||A||_2\ ||A^{-1}||_2$$称为谱条件数

性质：
对任何非奇异矩阵A，有Cond(A)≥1。
对任何非奇异矩阵A，非零常数c，有 Cond(cA) = Cond(A) 
若P为正交矩阵，则K(P) =1，且K(PA)=K(AP)=K(A) 
若A=AT，$$K(A)=\frac{|λ_{max}(A)|}{|λ_{min}(A)|}$$

线性方程组Ax=b解的相对误差直接与A的条件数相关:

- A的条件数Cond(A)相对大(>>1)，称Ax=b是病态方程组/坏条件，或A是病态的；
- 当A的条件数Cond(A)相对小，称Ax=b是良态方程组/好条件，或A是良态的。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323165821.png" alt="微信截图_20250323165821" style="zoom:50%;" />

### 3.2.3 相对误差的事后估计（近似解可靠性判别）

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323165857.png" alt="微信截图_20250323165857" style="zoom:50%;" />

- Cond(A)越小，相对误差越小
- 近似解的精度不仅依赖于残差向量r，也与矩阵A的条件数有关

判别病态方程组：

- 当A的行列式值相对小，或A某些行/列近似线性相关，方程组可能病态
- 若用选主元消去法求解Ax=b，在A消去中出现小主元，方程组可能病态
- 当A元素数量级相差很大且无一定规则，方程组可能病态
- 估计条件数，若条件数较大，则方程组病态

迭代求精：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323170120.png" alt="微信截图_20250323170120" style="zoom:50%;" />

### 3.2.4 迭代法

#### 基本思想

同步迭代和异步迭代法：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323170316.png" alt="微信截图_20250323170316" style="zoom:50%;" />

由Ax=b解出x=Gx+f

任取初始向量$$X^{(0)}$$，$$X^{(1)}=GX^{(0)}+f$$，$$X^{(k+1)}=GX^{(k)}+f$$

构造向量序列{$$x^{(k)}$$} 求方程的近似解的方法，称为一阶定常迭代法，G为该迭代法的迭代矩阵。
<img src="D:\新建文件夹 (5)\img1\微信截图_20250323170643.png" alt="微信截图_20250323170643" style="zoom:50%;" />

#### 基本迭代方法

A分裂为A=M-N
分裂阵M：可选择的非奇异阵，Mx=d易于求解，M选为A的某种近似
$$Ax=b$$        $$Mx=Nx+b$$           $$x=M^{-1}Nx+M^{-1}b$$
迭代方程：<img src="D:\新建文件夹 (5)\img1\微信截图_20250323170941.png" alt="微信截图_20250323170941" style="zoom:50%;" />

选取不同的M阵就是不同迭代法

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323171026.png" alt="微信截图_20250323171026" style="zoom: 67%;" />

##### 雅各比迭代法（同步迭代法）

设A是非奇异矩阵且$$a_{ii}\neq 0$$，令M=D，N=L+U
$$x^{(k+1)}=Jx^{(k)}+f$$ ，$$J=D^{-1}(L+U)$$,       $$f=D^{-1}b$$

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323171413.png" alt="微信截图_20250323171413" style="zoom:50%;" />

##### 高斯-赛德尔(Gauss-Seidel)迭代法（异步迭代法）

令M=D-L和N=U

$$x^{(k+1)}=Gx^{(k)}+f$$ ，$$G=(D-L)^{-1}U$$,       $$f=(D-L)^{-1}b$$

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323171642.png" alt="微信截图_20250323171642" style="zoom: 67%;" />

#### 迭代终止准则

近似相对百分比误差
<img src="D:\新建文件夹 (5)\img1\微信截图_20250323171737.png" alt="微信截图_20250323171737" style="zoom:50%;" />

对所有的i，近似相对百分误差小于预设的εs时，迭代终止。或者误差为<img src="D:\新建文件夹 (5)\img1\微信截图_20250323171849.png" alt="微信截图_20250323171849" style="zoom: 50%;" />

#### 迭代法收敛性

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323172104.png" alt="微信截图_20250323172104" style="zoom:50%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323172147.png" alt="微信截图_20250323172147" style="zoom:50%;" />

Jacobi迭代法收敛的充要条件是$$ρ(J)<1$$     $$(J=D^{-1}(L+U))$$
G-S迭代法收敛的充要条件是$$ρ(G)<1$$      $$(G=(D-L)^{-1}U)$$

如果A为（按行或列）严格对角占优阵，则Ax=b的Jacobi方法和G-S方法都收敛。G-S迭代法比Jacobi迭代法收敛得快。实际上，如果A为严格对角占优阵，可以证明， $$||J||_∞<1$$并且$$||G||_∞<1$$，因此，Jacobi方法和G-S方法都收敛。

如果A为对称正定矩阵，G-S迭代收敛。

#### 逐次超松驰迭代法(SOR，Successive Over-Relaxation)

在G-S方法上修改
<img src="D:\新建文件夹 (5)\img1\微信截图_20250323172622.png" alt="微信截图_20250323172622" style="zoom: 67%;" />

其中<img src="D:\新建文件夹 (5)\img1\微信截图_20250323172653.png" alt="微信截图_20250323172653" style="zoom:67%;" />

- ω=1，SOR方法即为G-S方法
- 0<ω<1，结果为当前迭代结果和上一次迭代结果的加权平均，称为低松弛方法。用于使得非收敛方程组收敛或者克服振荡加速收敛。
- 1<ω<2，超松弛方法：隐含假设：新值沿正确方向向真实解移动，但是移动的速度慢；用于加速已知是收敛的方程组的收敛速度；根据经验确定ω值

矩阵形式
<img src="D:\新建文件夹 (5)\img1\微信截图_20250323172843.png" alt="微信截图_20250323172843" style="zoom:50%;" />

## 3.3 MATLAB自带函数

<img src="D:\新建文件夹 (5)\img1\微信截图_20250323173010.png" alt="微信截图_20250323173010" style="zoom: 67%;" />

| 方法             | 稳定性     | 精度           | 应用范围                                           | 编程难度                           | 备注                    |
| ---------------- | ---------- | -------------- | -------------------------------------------------- | ---------------------------------- | ----------------------- |
| 图解法           | -          | 差             | 受限                                               | -                                  | 比数值方法耗时          |
| 克莱默法则       | -          | 受舍入误差影响 | 受限                                               | -                                  | 方程数多于3个时计算复杂 |
| 列主元高斯消元法 | -          | 受舍入误差影响 | 一般，适用于方程组系数矩阵为低阶稠密矩阵、带状矩阵 | 中等，计算量较小，存储量较大       | -                       |
| LU分解           | -          | 受舍入误差影响 | 一般，适用于方程组系数矩阵为低阶稠密矩阵、带状矩阵 | 中等，计算量较小，存储量较大       | 常用；进行矩阵求逆计算  |
| 迭代法           | 可能不收敛 | 优秀           | 收敛时，适用于大型稀疏线性方程组                   | 较简单，计算量有时较大，存储量较小 | -                       |

# 四，插值和拟合

问题：有的函数虽有表达式，但较复杂，也可用简单的函数g(x)来逼近它
  	  某些变量之间的函数关系y=f(x)存在，但没有f(x)的解析式，y=f(x)以函数表格或曲线形式给出

要求：根据函数表推算该函数在某些点上的函数值。
解决与该函数有关的一些问题，如分析函数的性态，研究y=f(x)的变化规律，求导数、积分、零点与极值点等。

## 4.1 插值问题

### 4.1.1 定义

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322164510.png" alt="微信截图_20250322164510" style="zoom:67%;" />

### 4.1.2 插值函数类

代数多项式：选取多项式Pn作为插值函数，Pn(x)称为插值多项式。
$$
p_n(x)=\sum^n_{i=0}a_ix^i
$$
有理函数：用有理函数（多项式的商）作为插值多项式。
$$
\Phi^{n,m}(x)=\frac{P_n(x)}{Q_m(x)}=\frac{p_0+p_1x_1+...+p^nx^n}{q_0+q_1x_1+...+q^mx^m}
$$
有理插值可使区间内插值误差分布较为均匀，特别适用于某些被插函数具有无穷间断点的附近，这种情况下若用多项式逼近效果很差。

三角函数：选取正弦和余弦等三角函数作为插值函数。

### 4.1.3 插值函数唯一性定理

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322165223.png" alt="微信截图_20250322165223" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322165338.png" alt="微信截图_20250322165338" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322165422.png" alt="微信截图_20250322165422" style="zoom:67%;" />

### 4.1.4 插值余项——截断误差

Rn=f(x)-Pn(x)

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322165852.png" alt="微信截图_20250322165852" style="zoom:67%;" />

插值多项式 仅与已知数据有关，与f(x)原本形式无关，但是余项与f(x)密切相关。
若f(x)本身是一个不超过n次的多项式，那么Pn(x)=f(x)
对多项式插值，增加阶数不一定能提高精度，一般用3-4个。
插值点x不能位于插值区间之外的远处。如果数据表中包含的点多于插值所需的数目，则在每次插值时，就必须选取表中合适位置的点。

### 4.1.5 事后估计

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322170139.png" alt="微信截图_20250322170139" style="zoom:67%;" />

## 4.2 插值方法

### 4.2.1 拉格朗日插值多项式

对于n个点，先求出每个点的基函数对于的lk(x)，然后再求Ln(x)

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322170831.png" alt="微信截图_20250322170831" style="zoom:67%;" />

线性插值(n=1)两个点

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322171051.png" alt="微信截图_20250322171051" style="zoom:67%;" />

二次(抛物线)插值(n=2)三个点

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322171137.png" alt="微信截图_20250322171137" style="zoom:67%;" />

选用更小的区间插值得出的结果更优
高次插值往往优于低次插值

#### 内插与外推

内插：插值点位于插值区间内部
外推：插值点位于插值区间外部但是与端点较近。

采用外推法时插值点x不宜位于插值区间之外的远处。

#### 缺点

缺点：没有承袭性，增加一个节点，所有基函数都要重新算

当插值节点在区间[a,b]上，适当加密，其误差在多数情况下会小些，但节点过多，不仅高次Ln(x)计算量大，精度也不一定好。$$lim_{n->\infty}L_n(x)=f(x)$$一般不成立。

#### 代码实现

```matlab
syms x;
function f=lagrange(x,X,Y)
    n=length(X);
    f=0;
    for i=1:n
        up=1;
        down=1;
        for j=1:n
            if i~=j
                up=up*(x-X(j));%求基函数分子
            end    
        end
        for j=1:n
            if i~=j
                down=down*(X(i)-X(j));%求基函数分母
            end    
        end
        lk=up/down;%基函数
        f=f+Y(i)*lk;%累加
    end
end
```

### 4.2.2 牛顿插值法

#### 原理

承袭性：$$N_{n+1}(x)=N_n(x)+q_{n+1}(x)$$

![微信截图_20250322172132](D:\新建文件夹 (5)\img1\微信截图_20250322172132.png)

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322172245.png" alt="微信截图_20250322172245" style="zoom:80%;" />

#### 有限差商

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322172822.png" alt="微信截图_20250322172822" style="zoom:67%;" />

重点在于右上角的公式

这样可得
a0=f[x0]
a1=f[x0,x1]
a2=f[x0,x1,x2]
an=f[x0,x1...xn]
牛顿插值基本多项式：

![微信截图_20250322181924](D:\新建文件夹 (5)\img1\微信截图_20250322181924.png)

拉格朗日插值多项式与牛顿插值多项式是同一个n次多项式。

#### 误差估计

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322173249.png" alt="微信截图_20250322173249" style="zoom:67%;" />

n+1阶和n阶估计值之差小于真实误差，因此采用两次迭代结果之差无法作为迭代的停止准则。实际上，高次多项式插值往往会发散。

#### 等距插值

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322173757.png" alt="微信截图_20250322173757" style="zoom: 80%;" />

差商与有限差分的关系

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322173922.png" alt="微信截图_20250322173922" style="zoom: 80%;" />

##### 牛顿向前插值公式

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322174208.png" alt="微信截图_20250322174208" style="zoom: 80%;" />

##### 牛顿向后插值公式

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322174347.png" alt="微信截图_20250322174347"  />

#### hermite插值多项式

构造插值函数除了函数值的条件以外，还需要一定的连续性条件，如一阶导数值等

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322174546.png" alt="微信截图_20250322174546" style="zoom: 50%;" />

#### Runge现象

 n越大，端点附近抖动越大，成为Runge现象

适当提高插值多项式的次数，可能提高计算结果的准确程度。然而次数越高意味着参加插值节点数越多，计算量大，插值函数曲线在部分区间上（两端）发生激烈振荡，插值多项式截断误差/计算余项偏大。

龙格/Runge 现象说明加密节点并不能保证所得到的插值多项式能更好地逼近f(x)，高次插值效果不一定比低次插值好。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322174814.png" alt="微信截图_20250322174814" style="zoom:50%;" />

#### 代码实现

```matlab
syms x;
function result=different(X,Y)
    n=length(X);
    result=0;
    for i=1:n
        down=1;
        for j=1:n
            if i~=j
                down=down*(X(i)-X(j));
            end    
        end 
        lk=Y(i)/down;
        result=result+lk;
    end    
end

function f=newton(x,X,Y)
    f=Y(1);
    n=length(X);
    for i=2:n
        k=1;
        result=different(X(1:i),Y(1:i));
        k=result;
        for j=1:i-1
            k=k*(x-X(j));
        end
        f=f+k;
    end
end
```

### 4.2.3 分段低次插值

把整个插值区间分成若干个小区间，在每个小区间上，进行低次插值
设a = x0< x1< x2< …< xn-1< xn = b，则节点把[a, b]分成n个小区间
当插值点x在第i个小区间[xi-1,xi]上时，采用一次线性插值公式，称为分段线性插值。也称为折线插值，即通过曲线n+1个点(xi,yi)的折线去近似替代曲线
在每个小区间[xi-1,xi,xi+1]上使用二次插值公式，称为分段抛物插值或分段二次插值

<img src="D:\新建文件夹 (5)\img1\微信截图_20250322175128.png" alt="微信截图_20250322175128" style="zoom:67%;" />

优点：分段低次插值函数公式简单，只要区间充分小，就能保证误差要求；局部性质好，如果修改了某个节点xi的值，仅在相邻的两个区间[xi-1, xi]，[xi, xi+1]受到影响

缺点：不能保证节点处插值函数的导数连续，因而不能满足某些工程上技术上曲线光滑性的要求

#### 代码实现

```matlab
syms x;
function f=cut(x,X,Y)%分段线性插值，可以改区间
    f_set=[];
    n=length(X);
    for i=1:n-1
        X_part=X(i:i+1);
        Y_part=Y(i:i+1);
        f_element=lagrange(x,X_part,Y_part);
        f_set=[f_set,f_element];
    end
    f=f_set(1).*(x>=X(1)&x<=X(2));
    for i=2:length(f_set)
        f=f+f_set(i).*(x>X(i)&x<=X(i+1));
    end
end
```

### 4.2.4 样条插值

线性样条：

- 分段线性插值
- 节点处一阶导数不连续（不光滑）

二次样条：

-  在节点处一阶导数连续
- 每两个相邻节点组成的区间中推导一个不 高于二阶的多项式

三次样条：

- 节点处具有连续的一阶、二阶导数节点处具有连续的一阶、二阶导数
- 每两个相邻节点组成的区间中推导一个不 高于三阶的多项式
- 三阶导数和高阶导数可能不连续

定义：设f(x) 是区间[a,b]上的一个二次(m-1次)连续可微函数。在区间上给定一组节点： a=x0 <…<xn=b,设函数
                                                                ![微信截图_20250329101218](D:\新建文件夹 (5)\img1\微信截图_20250329101218.png)

满足条件 ：

- S(x)在区间[a,b]上存在二阶(m-1阶)的连续导数。
- 每个子区间[x(i−1) ,xi ]上Si (x)都是一个不高于3次(m次)的多项式；    
- 满足插值条件S(xi )=f(xi )，i=0,…,n。

那么S(x)为函数f(x)关于节点x0，x1，...，xn的三次(m次)样条插值函数，简称三次(m次)样条。

#### 二次样条

$$
f_i(x)=a_ix^2+b_ix+c_i\ \ \ \ x\in[x_{i-1},x_i]\ \ \ \ i=1,2,...,n
$$

相邻多项式在内部节点处函数值相等
$$
a_{i-1}x_{i-1}^2+b_{i-1}x_{i-1}+c_{i-1}=f(x_{i-1})\\
a_{i}x_{i-1}^2+b_{i}x_{i-1}+c_{i}=f(x_{i-1})
$$
第一个和最后一个函数通过端点
$$
a_1x_0^2+b_1x_0+c_1=f(x_0)\\
a_nx_n^2+b_nx_n+c_n=f(x_n)
$$
内部节点的一阶导数相等
$$
2a_{i-1}x_{i-1}+b_{i-1}=2a_ix_{i-1}+b_i\ \ \ \ i=2,3,...,n
$$
 在第一个节点处二阶导数为0，a1=0，连接前两点的为一条直线。

#### 三次样条插值函数

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329104158.png" alt="微信截图_20250329104158" style="zoom:67%;" />

#### 三弯矩法

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329104323.png" alt="微信截图_20250329104323" style="zoom:67%;" />

##### 边界条件1 

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329104448.png" alt="微信截图_20250329104448" style="zoom: 67%;" />

##### 边界条件2 

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329104517.png" alt="微信截图_20250329104517" style="zoom: 67%;" />

##### 边界条件3

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329104558.png" alt="微信截图_20250329104558" style="zoom:67%;" />

- 简单插值的次数与节点个数有关，n+1个节点上要用n次多项式来 插值，而样条插值多项式的次数与节点个数无关，便于在多个节 点上用低次插值。
- 一般的分段低次插值，每段上插值多项式不同，各段表达式之间 没有内在联系，而样条插值多项式各段之间有联系。
- 样条多项式往往只需已知m-1个边界节点上的导数值就够了，其 余节点上的导数值是自然形成的

插值法的缺陷：

- 由实验提供的数据带有测试误差，插值函数会保留数据的全部测 量误差
- 当插值函数的阶数较高时，曲线摆动很大，而求得的插值函数与 实验规律可能偏离甚远
- 实验数据往往很多，用插值法得到的近似表达式缺乏实用价值

## 4.2 拟合问题

### 4.2.1 曲线拟合

 从一组实验测量数据中(xi ,yi ) (i=1,…,m)找出实验规律的数学表达式，即求函数y=f(x)的 一个近似表达式y=ϕ(x)（经验公式）

构造一个能逼近列表数据的近似的数学表达式，使各数据点从总体上最贴近，而不一 定要求构造的函数曲线通过所给数据点

从几何上来看，就是通过给定的m个数据点(xi ,yi )，求曲线y=f(x) 的一条近似曲线y=ϕ(x)

#### 最小二乘法

 一般情况下，不要求近似曲线y=ϕ(x)严格地经过所有数据点 (xi ,yi )(i=1,2…,m)，即不要求拟合函数ϕ(x)在xi 处的偏差（残差）δi =ϕ(xi )−yi 严格地等于0。

为使近似曲线能尽量反映所给数据点的变化趋势，要求偏差δi 适当地小

- 偏差绝对值之和最小∑|δi |
- 最大偏差绝对值最小max|δi 
- 偏差平方和最小∑|δi 2|——最小二乘原则

对于给定数据(xi ,yi )，要求在某个函数类Φ中寻求一个函数ϕ*(x)，使
![微信截图_20250329112200](D:\新建文件夹 (5)\img1\微信截图_20250329112200.png)

##### 基本环节

确定ϕ(x)的形式：通常的作法是描绘出数据点(xi, yi)，然后根据这些点的分布情 况来选择ϕ(x)的形式。
求最小二乘解：求满足条件的近似函数ϕ*(x)。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329112545.png" alt="微信截图_20250329112545" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329112627.png" alt="微信截图_20250329112627" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329112652.png" alt="微信截图_20250329112652" style="zoom:80%;" />

##### 最小二乘解的存在唯一性

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329112738.png" alt="微信截图_20250329112738" style="zoom:67%;" />

### 4.2.2 代数多项式拟合

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329112819.png" alt="微信截图_20250329112819" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329112844.png" alt="微信截图_20250329112844" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329112858.png" alt="微信截图_20250329112858" style="zoom:67%;" />

### 4.2.3 选择合适的拟合公式

在作数据拟合时，选择合适的拟合数学公式是很重要的。通常最好是选用所给数据预先 作出列表函数的曲线图，再根据曲线的大致形状，选择和确定合适的拟合数学公式形状， 一味采用多项式拟合并不一定可取。

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329113014.png" alt="微信截图_20250329113014" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329113029.png" alt="微信截图_20250329113029" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329113050.png" alt="微信截图_20250329113050" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329113103.png" alt="微信截图_20250329113103" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329113358.png" alt="微信截图_20250329113358" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329113415.png" alt="微信截图_20250329113415" style="zoom:67%;" />

### 4.2.4 扩展内容

<img src="D:\新建文件夹 (5)\img1\微信截图_20250329113717.png" alt="微信截图_20250329113717" style="zoom:67%;" />

### 4.2.5 自带函数

| 函数         | 描述                             |
| ------------ | -------------------------------- |
| polyfit      | 根据数据用多项式进行最小二乘拟合 |
| interp1      | 一维插值（查表）                 |
| interp1q     | 快速一维线性插值                 |
| interp2      | 二维插值                         |
| interpn      | n维插值                          |
| spline,csape | 三次样条插值                     |
| ppval        | 分段多项式估计函数               |
| cftool       | Curve fitting Tool               |

## 4.3 总结

相同点：

-  从函数角度看，插值法与最小二乘法都是一种根据函数表求函数的近似 表达式的问题，属于函数逼近问题。
- 从几何上看，二者都是根据一列数据点求曲线的近似曲线问题，是曲线 拟合问题。

不同点：

- 插值法根据插值条件来选择近似函数；最小二乘法根据“偏差平方和最 小”原则选择近似函数。

# 五 积分和微分

## 5.1 数值微分

### 5.1.1 差商近似

#### 5.1.1.1 三种差商

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404092455.png" alt="微信截图_20250404092455" style="zoom:67%;" />

#### 5.1.1.2 误差

h越小，误差越小，舍入误差越大。

事后估计：增加泰勒级数展开式的项数可以提高精度。

高精度微分公式：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404092825.png" alt="微信截图_20250404092825" style="zoom:67%;" />

例：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404093005.png" alt="微信截图_20250404093005" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404093011.png" alt="微信截图_20250404093011" style="zoom:67%;" />

### 5.1.2 插值型数值微分

用插值函数的导数近似为原函数的导数

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404093656.png" alt="微信截图_20250404093656" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404093720.png" alt="微信截图_20250404093720" style="zoom:67%;" />

特例：n=1

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404093751.png" alt="微信截图_20250404093751" style="zoom:67%;" />

n=2

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404093820.png" alt="微信截图_20250404093820" style="zoom:67%;" />

- 用三次样条插值的导数近似被插值函数的导数，效果相当好
- 在实际问题中使用哪种公式要视具体问题而定。有时三种公式都要用到，给定一个列表函数，对函数中间各点都可使用精度较高的中心差商公式，但起始点只能使用前差公式，终点则使用后差公式。
- 一般情况下，三点公式比两点公式准确，步长越小结果越准确。但当余项中的高阶导数无界或计算过程中的舍入误差超过截断误差时，这个结论不成立。

## 5.2 数值积分

定义数值积分是离散点上的函数值的线性组合

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404094100.png" alt="微信截图_20250404094100" style="zoom:67%;" />

- 如果一个求积公式对任何次数不超过m次的代数多项式都准确成立，而对于m+1次的代数多项式不能准确成立，即$$R(f)\neq0$$，则称求积公式$$I_n(f)$$的代数精度是m
- 梯形公式的代数精度m=1：对不高于1次的代数多项式都准确成立，对2次以上的代数多项式存在误差。
- 一个求积公式的代数精度越高，就能对更多的被积函数准确或较准确地成立

用插值函数的积分，作为数值积分：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404094356.png" alt="微信截图_20250404094356" style="zoom:67%;" />

### 5.2.1 Newton-Cotes积分

采用拉格朗日插值多项式P(x)来逼近f(x)，将积分区间n等分，取分点为求积节点，并作变量替换

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404094618.png" alt="微信截图_20250404094618" style="zoom:67%;" />

#### 5.2.1.1 梯形公式(n=1)

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404094822.png" alt="微信截图_20250404094822" style="zoom:67%;" />

例：由于$$\xi$$无法计算，用平均值代替

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404095303.png" alt="微信截图_20250404095303" style="zoom:67%;" />

#### 5.2.1.2 Simpson公式(n=2)

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404095549.png" alt="微信截图_20250404095549" style="zoom:67%;" />

其中$$h=\frac{b-a}{2}$$，其中h的系数为1/3，称为辛普森1/3法则

例：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404095815.png" alt="微信截图_20250404095815" style="zoom:67%;" />

#### 5.2.1.3 辛普森3/8法则(n=3)

构造区间上的四点三次Lagrange插值多项式，并逼近被积函数

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404100047.png" alt="微信截图_20250404100047" style="zoom:67%;" />

其中$$h=\frac{b-a}{3}$$

例：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404100423.png" alt="微信截图_20250404100423" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404100432.png" alt="微信截图_20250404100432" style="zoom:67%;" />

对于n大的，可以分成若干个两段+三段

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404100729.png" alt="微信截图_20250404100729" style="zoom:67%;" />

#### 5.2.1.4 数值积分的稳定性

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404100809.png" alt="微信截图_20250404100809" style="zoom:67%;" />

余项：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404100835.png" alt="微信截图_20250404100835" style="zoom:67%;" />

#### 5.2.1.5 复合N-C公式

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404102448.png" alt="微信截图_20250404102448" style="zoom:67%;" />

##### 复合梯形公式

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404102524.png" alt="微信截图_20250404102524" style="zoom:67%;" />

例：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404102721.png" alt="微信截图_20250404102721" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404102729.png" alt="微信截图_20250404102729" style="zoom:67%;" />

#####  复合辛普森公式

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404103648.png" alt="微信截图_20250404103648" style="zoom:67%;" />、
<img src="D:\新建文件夹 (5)\img1\微信截图_20250404103703.png" alt="微信截图_20250404103703" style="zoom:67%;" />

##### 收敛阶

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404103806.png" alt="微信截图_20250404103806" style="zoom:67%;" />

复合辛普森收敛阶高，比复合梯形好用。

##### 非等距积分

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404104019.png" alt="微信截图_20250404104019" style="zoom:67%;" />

事后估计与误差自适应

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404104108.png" alt="微信截图_20250404104108" style="zoom:67%;" />

递推公式

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404104129.png" alt="微信截图_20250404104129" style="zoom:67%;" />

#### 5.2.1.6 重积分

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404104330.png" alt="微信截图_20250404104330" style="zoom:67%;" />

### 5.2.2 龙贝格（Romberg）积分

外推算法：用若干个积分近似值来推算更精确的新的近似值的方法

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404104542.png" alt="微信截图_20250404104542" style="zoom:67%;" />

#### 计算过程

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404104750.png" alt="微信截图_20250404104750" style="zoom:67%;" />

例：

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404105056.png" alt="微信截图_20250404105056" style="zoom:50%;" />

#### 数值微分的外推法

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404105024.png" alt="微信截图_20250404105024" style="zoom:67%;" />

### 5.2.3 高斯积分公式

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404105748.png" alt="微信截图_20250404105748" style="zoom:67%;" />

#### 两点高斯公式

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404105906.png" alt="微信截图_20250404105906" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404110109.png" alt="微信截图_20250404110109" style="zoom:67%;" />

#### 几个常用的高斯多项式

##### legendre

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404110240.png" alt="微信截图_20250404110240" style="zoom:67%;" />

Gauss-Legendre求积公式

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404110659.png" alt="微信截图_20250404110659" style="zoom:67%;" />

求积公式节点系数表

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404110713.png" alt="微信截图_20250404110713" style="zoom:67%;" />

##### Hermite

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404110938.png" alt="微信截图_20250404110938" style="zoom:67%;" />

#### 优缺点

优点：计算量小，精度高

缺点：n改变大小时，节点和系数几乎都改变；利用余项控制精度困难；需要计算节点处的函数值，不适用于函数表达式未知的情况

较多采用复合求积的方法，将积分区间分成m个等长的小区间，在每个小区间上使用同一低阶Gauss求积公式算出积分的近似值，再相加

## 5.3 MATLAB自带函数

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404111637.png" alt="微信截图_20250404111637" style="zoom:67%;" />

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404111646.png" alt="微信截图_20250404111646" style="zoom:67%;" />



