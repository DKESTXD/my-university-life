## 1 问题一

可以从$$x_0=a$$开始，采用如下迭代公式计算任何数a的立方根：$$x_{k+1}=\frac{2x_k}{3}+\frac{a}{3x_k^2}$$。请编程实现该迭代法，要求保证计算结果保留五位有效数字，并自行选择一个数验证。

### 1.1 解题思路

由公式可以用while 1循环无限迭代，且由于最终结果只需保留五位有效数字，所以循环结束的条件可以选为相邻两次迭代值的差小于$$10^{-6}$$便可满足，但是为了更准确也可以选eps，即内置的机器精度。

故总思路为：定义a值保留初始值，双精度值x与x_new用于迭代 ，在每次循环中计算新的x_new  并对 |x_new-x| 进行判断其是否收敛，如果其小于定义的误差限，便可跳出循环，并对最后一次的x_new值进行保留五位有效数字处理。

### 1.2 代码实现

```matlab
double x;
double x_new;
x=input("输入值");
a=x;
while 1
    x_new=(2*x+a/(x^2))/3;
    if abs(x_new-x)<1e-6 %eps
        break;
    end
    disp(abs(x_new-x));
    x=x_new;
end
disp(abs(x_new-x));
x=vpa(x_new,5);  %由于matlab默认format short，即保留小数点后五位，故用vpa函数限定有效数字位数
disp(x);
```

### 1.3 结果验证

输入值为3
将误差限规定在$$10^{-6}$$时每次迭代时前后两者差如下

<img src="D:\新建文件夹 (5)\img1\微信截图_20250228082605.png" alt="微信截图_20250228082605" style="zoom:67%;" />

最终结果为$$x=1.4422$$

将误差限规定为eps时每次迭代时前后两者差如下

<img src="D:\新建文件夹 (5)\img1\微信截图_20250228083214.png" alt="微信截图_20250228083214" style="zoom: 67%;" />

最终结果仍为$$x=1.4422$$
由计算器计算$$3^{\frac{1}{3}}=1.4422495703074$$

可见$$10^{-6}$$的误差限足以达到所需精度。



输入值为1100
结果为![微信截图_20250228083628](D:\新建文件夹 (5)\img1\微信截图_20250228083628.png)
由计算器计算$$1100^{\frac{1}{3}}=10.322801154563$$



输入值为112233445566778899
结果为![微信截图_20250228084526](D:\新建文件夹 (5)\img1\微信截图_20250228084526.png)
由计算机计算$$112233445566778899^{\frac{1}{3}}=482363.1234129$$

## 2 问题二

编程计算得到matlab单精度和双精度数据类型的机器精度，并与内置机器精度函数eps的结果进行比较。

### 2.1 解题思路

机器精度$$\varepsilon$$即满足1+$$\varepsilon$$>1的最小浮点数。那么定义一个初始值1，将其无限减小，直到达到1+$$\varepsilon$$>1的要求跳出循环，最后得到的$$\varepsilon$$的上一步循环值就是最后的机器精度值。

### 2.2 代码实现

```matlab
epsilon_double=1;
epsilon_single=1;
epsilon_double=double(epsilon_double);
epsilon_single=single(epsilon_single);
while(1+epsilon_double)>1
    epsilon_double=epsilon_double/2;
end
while(1+epsilon_single)>1
    epsilon_single=epsilon_single/2;
end
epsilon_single=epsilon_single*2;
epsilon_double=epsilon_double*2;
disp(['单精度为：',num2str(epsilon_single)]);
disp(['双精度为：',num2str(epsilon_double)]);
disp(['内置精度默认为：',num2str(eps)]);
disp(['内置精度double为：',num2str(eps("double"))]);
disp(['内置精度single为：',num2str(eps("single"))]);
```

分别定义了epsilon_double与epsilon_single来定义双精度与单精度的机器精度，在无限while 1循环中对其不断除以2，最后的得到的值再乘2 就是对应的机器精度。而eps是matlab内部自带的机器精度值。

### 2.3 结果验证

运行结果如下

![微信截图_20250228123158](D:\新建文件夹 (5)\img1\微信截图_20250228123158.png)

可得到单精度值处在不小于$$10^{-8}$$的边缘，双精度值处在不小于$$10^{-16}$$的边缘，而内置精度值默认为双精度数据类型的机器精度，用循环的方法测得的单双精度与其内置精度是一致的。

## 3 个人心得

matlab在解决实际工程问题中应用广泛，因此使用时对误差、有效数字等的约束也更严格。通过第一个实验体会到了截断误差的影响，以及选用不同误差限作为判断对程序运行及结果的影响；通过第二个实验熟悉了机器精度的定义、求法，以及内置精度eps默认即双精度数据类型的精度。

