## 1 问题描述

Matlab内置函数humps为
$$
f(x)=\frac{1}{(x-0.3)^2+0.01}+\frac{1}{(x-0.9)^2+0.04}-6
$$
要求：
(1)采用数值微分方法计算函数在0.5处的一阶导数值，并分析误差。
(2)采用不同的数值积分方法计算函数在[0,1]上的积分结果，并分析误差。

## 2 问题分析

对f(x)求微分，得到解析解
$$
f^{'}(x)=-\frac{2(x-0.3)}{((x-0.3)^2+0.01)^2}-\frac{2(x-0.9)}{((x-0.9)^2+0.04)^2}
$$
把0.5代入，$$f^{'}(0.5)=-140$$

对f(x)求积分，得到解析解
$$
\int f(x)dx=10arctan(10x-3)+5arctan(5x-4.5)-6x+c
$$
把[0，1]代入，用计算器算得$$\int^1_0f(x)dx=29.858325395498675089500892382438$$

原函数图象为
<img src="D:\新建文件夹 (5)\img1\微信截图_20250404115324.png" alt="微信截图_20250404115324" style="zoom:67%;" />

## 3 代码实现

### 3.1 微分算法

差商近似的高精度微分公式，由
<img src="D:\新建文件夹 (5)\img1\微信截图_20250404120603.png" alt="微信截图_20250404120603" style="zoom:67%;" />

```matlab
function result=diff(f,x0,h)
    result=(-f(x0+2*h)+4*f(x0+h)-3*f(x0))/(2*h);
end
```

一阶微分三点公式。
<img src="D:\新建文件夹 (5)\img1\微信截图_20250404121324.png" alt="微信截图_20250404121324" style="zoom:50%;" />

用中心差商公式

```matlab
function result=diff_three(f,x0,h)
	result=(f(x0+h)-f(x0-h))/(2*h);
end
```

### 3.2 积分算法

#### Newton-Cotes积分

分别定义梯形公式，辛普森公式，辛普森3/8公式

```matlab
function result=trape(f,X)
    result=(X(2)-X(1))*(f(X(2))+f(X(1)))/2;
end
function result=simpson(f,X)
    h=(X(3)-X(1))/2;
    result=h*(f(X(1))+4*f(X(2))+f(X(3)))/3;
end
function result=simpsom8(f,X)
    h=(X(4)-X(1))/3;
    result=3*h*(f(X(1))+3*f(X(2))+3*f(X(3))+f(X(4)))/8;
end
```

分别意味着区间等分为1，2，3块时，对应的X分别有2，3，4的端点

```matlab
function X=separate(d,a,b)%均分点的函数
    X=[];
    h=(b-a)/(d-1);
    for i=1:d
        x=a+h*(i-1);
        X=[X,x];
    end    
end
```

但是仅仅将其分成1、2、3块，精度远远不够。需要分成更多块，需要复合Newton-Cotes公式，其实本质上就是把这些块按照3、2或1将相邻块组合起来，再分别用对应的公式，再将每块的结果加起来。

将区间分成120块，分别全用辛普森3/8公式，全用辛普森公式，全用梯形公式和两个辛普森3/8公式加三个辛普森公式的组合。

```matlab
X=separate(121,0,1);
sum1=0;%全用辛普森3/8公式
sum2=0;%全用辛普森公式
sum3=0;%全用梯形公式
sum4=0;%两个辛普森3/8公式加三个辛普森公式
for(i=1:40)
   sum1=sum1+simpson8(f_handle,X(3*i-2:3*i+1)); 
end
for(i=1:60)
   sum2=sum2+simpson(f_handle,X(2*i-1:2*i+1));
end
for(i=1:120)
   sum3=sum3+trape(f_handle,X(i:i+1));
end
for(i=1:20)
   sum4=sum4+simpson8(f_handle,X(3*i-2:3*i+1));
end
for(i=30:59)
   sum4=sum4+simpson(f_handle,X(2*i+1:2*i+3));
end    
```

#### 龙贝格积分

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404133323.png" alt="微信截图_20250404133323" style="zoom: 67%;" />

用如图所示的公式来计算

```matlab
function [T,S,C,R]=romberg(k,f,a,b)
    T(1)=(b-a)*(f(b)+f(a))/2;
    for i=1:k
        sum=0;
        for j=1:2^(i-1)
            sum=sum+f(a+(2*j-1)*(b-a)/(2^i));
        end
        T(i+1)=T(i)/2+(b-a)*sum/(2^i);
    end    
    for i=1:k
        S(i)=(4*T(i+1)-T(i))/3;
    end    
    for i=1:k-1
        C(i)=(16*S(i+1)-S(i))/15;
    end  
    for i=1:k-2
        R(i)=(64*C(i+1)-C(i))/63;
    end  
end
```

其中k是最大指数，T是梯形序列，S是simpson序列，C是cotes序列，R是romberg序列。先求出全部的T序列，然后求出S，再依次求出C与R。

#### 高斯积分

选用legendre多项式，默认上下限为[-1,1]，需要先转化原函数。
$$
x=a_0+a_1x_d\\
a_0=\frac{a+b}{2}\\
a_1=\frac{b-a}{2}
$$
有$$x=\frac{1}{2}+\frac{1}{2}x_d$$，$$dx=\frac{1}{2}dx_d$$

原积分变为：
$$
\int^1_{-1}(\frac{1}{(0.5x_d+0.2)^2+0.01}+\frac{1}{(0.5x_d-0.4)^2+0.04}-6)\times \frac{1}{2}dx_d
$$
<img src="D:\新建文件夹 (5)\img1\微信截图_20250404142242.png" alt="微信截图_20250404142242" style="zoom:67%;" />

由节点与系数表，做出n=2~6的五个函数

```matlab
function result=gauss2(f)
    result=f(0.5773502692)+f(-0.5773502692);
end
function result=gauss3(f)
    result=0.5555555556*f(0.7745966692)+0.5555555556*f(-0.7745966692)+0.8888888889*f(0);
end
function result=gauss4(f)
    result=0.3478548451*(f(0.8611363116)+f(-0.8611363116))+0.6521451549*(f(0.3399810436)+f(-0.3399810436));
end
function result=gauss5(f)
    result=0.2369268851*(f(0.9061798459)+f(-0.9061798459))+0.4786286705*(f(0.5384693101)+f(-0.5384693101))+0.5688888889*f(0);
end
function result=gauss6(f)
    result=0.1713244924*(f(0.9324695142)+f(-0.9324695142))+0.3607615730*(f(0.6612093865)+f(-0.6612093865))+0.4679139346*(f(0.2386191861)+f(-0.2386191861));
end

```

本质上是纯加减乘除运算。

## 4 结果分析

```matlab
function result=error(y_true,y_pred)
    result=abs(y_true-y_pred)/abs(y_true);
end
```

定义求相对误差的函数

### 4.1 微分结果

真实值为-140

​    步长取0.1                        步长取0.01                 步长取0.001

![微信截图_20250404142824](D:\新建文件夹 (5)\img1\微信截图_20250404142824.png)![微信截图_20250404142840](D:\新建文件夹 (5)\img1\微信截图_20250404142840.png)![微信截图_20250404142944](D:\新建文件夹 (5)\img1\微信截图_20250404142944.png)

可见步长越小，预测值越准确，相对误差越小，而且一阶微分三点公式近似解的精度要高于高精度微分公式。

### 4.2 积分结果

真实值为29.858325395498675089500892382438

#### Newton-Cotes积分

不用复合公式时：

![微信截图_20250404143655](D:\新建文件夹 (5)\img1\微信截图_20250404143655.png)![微信截图_20250404143721](D:\新建文件夹 (5)\img1\微信截图_20250404143721.png)![微信截图_20250404143750](D:\新建文件夹 (5)\img1\微信截图_20250404143750.png)

此时辛普森3/8公式精度最高

用复合公式时，共分成120块：

![微信截图_20250404145905](D:\新建文件夹 (5)\img1\微信截图_20250404145905.png)<img src="D:\新建文件夹 (5)\img1\微信截图_20250404145916.png" alt="微信截图_20250404145916"  />![微信截图_20250404145933](D:\新建文件夹 (5)\img1\微信截图_20250404145933.png)![微信截图_20250404150105](D:\新建文件夹 (5)\img1\微信截图_20250404150105.png)

发现复合辛普森的误差最小，复合梯度的误差最大，而复合辛普森3/8与两者混用的误差均大于复合辛普森小于复合梯形。

符合理论值，理论上复合辛普森有四阶收敛性，收敛速度快，精度高；而复合梯度公式随着分的区间数增大，虽然总的误差会先变小，但是舍入误差会增大，最终精度受到限制。

#### 龙贝格积分

![微信截图_20250404150549](D:\新建文件夹 (5)\img1\微信截图_20250404150549.png)![微信截图_20250404150742](D:\新建文件夹 (5)\img1\微信截图_20250404150742.png)

自上而下每行依次为T，S，C，R序列。右侧自上而下为四个序列最后一个值的相对误差。

理论上其误差在四个序列中应该是递减的，即龙贝格积分精度最高。但是其真实结果是反过来的，可能是误差传递累积的问题。继续提高k的值。

当k=6时
<img src="D:\新建文件夹 (5)\img1\微信截图_20250404151746.png" alt="微信截图_20250404151746" style="zoom:67%;" />

此时T序列的精度遇到了瓶颈，S序列精度最高。

当k=8时
<img src="D:\新建文件夹 (5)\img1\微信截图_20250404151943.png" alt="微信截图_20250404151943" style="zoom:67%;" />

此时T与S序列的精度均不如C序列的精度，

当k=10时 
<img src="D:\新建文件夹 (5)\img1\微信截图_20250404152159.png" alt="微信截图_20250404152159" style="zoom:67%;" />

此时C与R序列都精度极高且非常接近。均比T和S序列高。

由此我们可以得出，R序列的精度上限最高，但是到达精度上限要求的k也越大。因此才会出现在k较小时精度不如T或R序列的现象，因为T与R序列在k较小时就能表现出较高的精度，但是随着k增大，算法的上限低。

#### 高斯积分

选用legendre多项式，n取2，3，4，5，6

<img src="D:\新建文件夹 (5)\img1\微信截图_20250404152633.png" alt="微信截图_20250404152633" style="zoom:80%;" /><img src="D:\新建文件夹 (5)\img1\微信截图_20250404152734.png" alt="微信截图_20250404152734" style="zoom:80%;" /><img src="D:\新建文件夹 (5)\img1\微信截图_20250404152745.png" alt="微信截图_20250404152745" style="zoom:80%;" /><img src="D:\新建文件夹 (5)\img1\微信截图_20250404152758.png" alt="微信截图_20250404152758" style="zoom:80%;" /><img src="D:\新建文件夹 (5)\img1\微信截图_20250404152817.png" alt="微信截图_20250404152817" style="zoom:80%;" />

随着n的增大，误差逐渐变小，理论上n足够大，精度就足够。虽然这种算法的精度远不如前两种。但是高斯积分算法的运算及其简单，只涉及函数值的加减乘除运算，不涉及拟合、递归等等，公式简单。但是缺点是规律性不强，改变n需要改变所有函数值及其系数，没有通解，要取更高精度解只能查节点与系数表。

## 5 个人心得

对于微分问题，只要步长够小，无论是高精度微分公式还是一阶微分三点公式，其精度都足够。运用差商近似可以将微分转化为线性运算，简化了计算过程。

对于积分问题，Newton-Cotes积分的辛普森积分精度最高，收敛性也最好，将积分区间分成尽量小的区间，再运用复合辛普森公式，一般可以得到较为精确的结果，而且原始公式简单，复合公式也不复杂，计算量不大。Romberg积分收敛速度最快，精度最高，k=10的时候，误差的数量级已经可以达到$$10^{-16}$$，缺点是原始公式与算法较为复杂，计算量大，时间复杂度高。高斯积分法的公式最简单，缺点是没有通解，只能查系数节点表，而且精度较差，但是鉴于其朴素的原始公式，能够达到这种精度也是非常强大的。